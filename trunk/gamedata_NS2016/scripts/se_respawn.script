--' by Stohe (Диденко Руслан)
---' revision and adaptation for NS_2012 lsclon 09.07.12 '---
--' Respawner. Схема обновления популяции всего всего всего в симуляции.

local math_random = math.random
local table_insert = table.insert
local table_remove = table.remove
local section_name = "respawn"
--' Настройка респавна:
-- frequent - Частота респавна: true - 12-36 часов, false - 24-72
-- time_spawn - Регулировка частоты срабатывания респавнеров.
-- def_cond - Регулировка шанса заспвнить обьект.
local frequent = game_options.respawn_frequent
local time_spawn = 172800
local def_cond = 80
--' Временной интервал между спавном:
local idle_spawn_preset = {
	seldom = time_spawn*2, -- 4 дня
	medium = time_spawn,   -- 2 дня
	often = time_spawn/2   -- сутки
}
-- Список респавнеров
local respawners = {}

function r_bool(spawn_ini,section,line,default)
	if spawn_ini:line_exist(section,line) then
		return spawn_ini:r_bool(section,line)
	end
	return default
end

function r_str(spawn_ini,section,line,default)
	if spawn_ini:line_exist(section,line) then
		return spawn_ini:r_string(section,line)
	end
	return default
end

function r_num(spawn_ini,section,line,default)
	if spawn_ini:line_exist(section,line) then
		return spawn_ini:r_float(section,line)
	end
	return default
end

function r_tab(spawn_ini,section,line,default)
	if spawn_ini:line_exist(section,line) then
		return parse_names(spawn_ini:r_string(section,line))
	end
	return default
end

function parse_names(s)
	local tabl = {}
	for name in string.gfind(s,"([%w_%-.\\]+)%p*") do
		table_insert(tabl,name)
	end
	return tabl
end

function r_spawns(spawn_ini,section,line,sectSpawnProps)
	local check = nil
	local c_data,comm,count,ltx,num_even,prob,rank,spawn,tabl,tab_spawn
	local def,num = 1,1
	local respawn_ini = sys_ini
	if spawn_ini:line_exist(section,line) then
		-- Вычитываем шанс для каждой секции
		tabl = parse_names(spawn_ini:r_string(section,line))
		count = #tabl
		tab_spawn = {}
		while num <= count do
			spawn = {}
			spawn.section = tabl[num]
			-- Проверяем что это не последняя запись
			num_even = tabl[num + 1]
			prob = num_even and tonumber(num_even)
			-- если это число:
			if prob then
				def = prob
				num = num + 1
			end
			spawn.prob = def
			num = num + 1
			table_insert(tab_spawn,spawn)
			-- Вычитываем настройки секций респавна и кешируем их.
			if sectSpawnProps[spawn.section] == nil then
				comm = r_str(respawn_ini,spawn.section,"community","nil")
				rank = r_str(respawn_ini,spawn.section,"spec_rank","nil")
				c_data = r_str(respawn_ini,spawn.section,"custom_data")
				ltx = c_data and ini_file(c_data)
				if ltx then
					if ltx:section_exist("smart_terrains") then
						-- респавнеры нпс под собственной логикой
						if ltx:line_exist("smart_terrains","none") then
								-- чтобы объекты, не удалялись при проверке на смарт
								check = true
						end
					end
				end
				sectSpawnProps[spawn.section] = {community = comm,rank = rank ,check = check}
			end
		end
	end
	return tab_spawn
end

---' -----------------------------------------
class "se_respawn" (cse_alife_smart_zone)
---' -----------------------------------------
--' Конструктор:
function se_respawn:__init(section) super(section)
	self.spawned_obj = {}      -- Таблица заспвненных объектов по идам.
	self.sectSpawnProps = {}   -- Таблица свойств секций респавна.
	self.rt_read = false       -- Флаг запуска таймера.
	self.init_params = false   -- Флаг первичной инициализации.
	self.first_spawned = false -- Флаг первого спавна.
end

--' Сохранение
function se_respawn:STATE_Write(packet)
	cse_alife_smart_zone.STATE_Write(self,packet)
	local count = #self.spawned_obj
	packet:w_u8(count)
	for i = 1, count do
		packet:w_u16(self.spawned_obj[i])
	end
	if self.tab_auto_dell then
		packet:w_bool(self.first_spawned)
	else
		if self.idle_spawn ~= -1 and self.respawn_time then
			utils.w_CTime(packet,self.respawn_time)
		end
	end
	if self.rand_position and self.rand_time then
			utils.w_CTime(packet,self.rand_time)
	end
end

--' Восстановление
function se_respawn:STATE_Read(packet,size)
	cse_alife_smart_zone.STATE_Read(self,packet,size)
	if editor() then
		return
	end
	local count = packet:r_u8()
	for i = 1, count do
		table_insert(self.spawned_obj,packet:r_u16())
	end
	if not packet:r_eof() then
		-- параметры будем читать только при необходимости
		respawn_params(self)
		if self.tab_auto_dell then
			self.first_spawned = packet:r_bool()
		else
			if self.idle_spawn ~= -1 then
					self.respawn_time = utils.r_CTime(packet)
			end
		end
	end
	if not packet:r_eof() then
		if self.rand_position and self.item_spawn then
			self.rand_time = utils.r_CTime(packet)
		end
	end
end

--' Инициализация объекта.
-- вызывается симулятором.
function se_respawn:on_register()
	cse_alife_smart_zone.on_register(self)
	respawn_params(self)
end

--' Обновление в офлайне.
function se_respawn:update()
	cse_alife_smart_zone.update(self)
	if not self.init_params then
		respawn_params(self)
	end
	-- только рандомный для предметов
	if self.rand_position and self.item_spawn then
		local game_time = game.get_game_time()
		local rand_time = self.rand_time
		if rand_time and (rand_time < game_time) then
			-- обнилим таймеры и удалим лишние объекты
			self.rand_time = nil
			self.respawn_time = nil
			self:remove_obj()
		end
		 -- обновление рандомного респавнера без парента выполняется только в онлайне
		if not self.parent then
			return
		end
	end
	self:execute()
end

--' Удаление рандомных объектов.
function se_respawn:remove_obj()
	local sim = alife()
	local obj,sobj,sobj_parent,id
	-- проверим ранее заспавненные объекты
	for i = #self.spawned_obj,1,-1 do
		id = self.spawned_obj[i]
		sobj = sim:object(id)
		if sobj then
			-- если объект не имеет парент - удалим
			sobj_parent = sobj.parent_id
			if sobj_parent == 65535 then
				obj = level.object_by_id(id)
				-- исключим удаление с текущей локи
				if not obj then
					sim:release(sobj,true)
				end
			end
		end
		-- удалим из таблицы
		table_remove(self.spawned_obj,i)
	end
end

--' Обновление в онлайне.
function se_respawn:update_online()
	-- серверный объект не прошел регистрацию
	if not self.init_params then
		return
	end
	local actor = db.actor
	local radius = self.respawn_radius
	-- в онлайне только если self.respawn_radius ~= -1
	if actor and radius >= 0 and actor:position():distance_to(self.position) >= radius then
		self:execute()
	end
end

--' Выполнение обновления респавнера.
function se_respawn:execute()
	local sim = alife()
	-- проверим, условия автоудаления
	if self.tab_auto_dell then
		self.auto_dell = xr_logic.pick_section_from_condlist(db.actor_proxy,self,self.tab_auto_dell) ~= nil
	end
	-- если условия выполнены и есть флаг спавна - очистим таблицы и удалим респавнер
	if self.auto_dell and self.first_spawned then
		self.spawned_obj = {}
		respawners[self:name()] = nil
		sim:release(self,true)
		return
	end
	local idle_spawn = self.idle_spawn
	local prob = xr_logic.pick_section_from_condlist(db.actor_proxy,self,self.tab_cond)
	local num = tonumber(prob)
	-- если респавнер запускается сторонними скриптами, или нет условий для спавна
	if idle_spawn == -1 or num == 0 then
		return
	end
	local game_time = game.get_game_time()
	local respawn_time = self.respawn_time
	-- проверим таймер спавна
	if not respawn_time or (respawn_time < game_time) then
		local idle_time,shift_time,timer
		-- если респавнер подлежит удалению, не записываем таймеры
		if not self.auto_dell then
			shift_time = idle_spawn/2
			-- если частый респавн
			if frequent then
				shift_time = shift_time/2
			end
			idle_time = game.CTime()
			idle_time:setHMSms(0,0,0,math_random(shift_time,shift_time*3)*1000)
			self.respawn_time = game_time + idle_time
			-- если рандомный респавнер предметов, запишем таймер обнуления
			if self.rand_position and self.item_spawn and not self.rand_time then
				timer,shift_time = amk.has_timer("blow_shift")
				if timer then
					idle_time = game.CTime()
					idle_time:setHMSms(0,0,0,shift_time/5)
					self.rand_time = game_time + idle_time
				end
			end
		end
		self:spawn(num)
	end
end

--' Попытка спаунить объекты.
function se_respawn:spawn(prob)
	local sim = alife()
	local count,id,sobj,obj_parent
	-- проверим ранее заспавненные объекты
	if not self.item_spawn then
		for i = #self.spawned_obj,1,-1 do
			id = self.spawned_obj[i]
			sobj = sim:object(id)
			if sobj then
				-- если объект - труп нпс или монстра
				if not npc_clsid(sobj:clsid()) or (npc_clsid(sobj:clsid()) and not sobj:alive()) then
					-- удалим из таблицы
					table_remove(self.spawned_obj,i)
				end
			-- если объекта уже несуществует
			else
				-- удалим из таблицы
				table_remove(self.spawned_obj,i)
			end
		end
	end
	-- определим количество для спавна
	count = self.max_spawn - #self.spawned_obj
	if count > 0 then
		-- если выполнены условия для удаления респавнера, поставим флаг
		if self.tab_auto_dell and not self.first_spawned then
			self.first_spawned = true
		end
		for i = 1, count do
			-- проверка шанса для кажждой попытки перенесена сюда, чтоб непрерывала цикл
			if math_random(100) <= prob then
				if self:create() == false then
					return
				end
			end
		end
	end
end

--' Создаем объект.
function se_respawn:create()
	local sim = alife()
	local spawn_section = ""
	local sum = 0
	local gv,lv,obj,parent_id,pos,prop,smart_id,sobj,story_id
		-- определим секцию для спавна
		for k,v in pairs(self.respawn_section) do
			sum = sum + v.prob
		end
		sum = math_random(0, sum)
		for k,v in pairs(self.respawn_section) do
			if sum <= v.prob then
				spawn_section = v.section
				break
			end
			sum = sum - v.prob
		end
		pos = self.position
		lv = self.m_level_vertex_id
		gv = self.m_game_vertex_id
		-- определим наличие парента и его позицию
		if self.parent then
			story_id = self.parent[math_random(#self.parent)]
			sobj = story_id and sim:story_object(story_id)
			if not sobj then
				return false
			end
			parent_id = sobj.id
			pos = sobj.position
			lv = sobj.m_level_vertex_id
			gv = sobj.m_game_vertex_id
			-- если рандомный респавнер с парентом - обнилим парент
			if parent_id and self.rand_position then
				parent_id = nil
			end
		end
		-- если рандомный респавнер без парента - сгенерируем позицию
		if self.rand_position and not self.parent then
			pos,lv,gv = self:generate_pos(gv)
		end
		-- спавним объект
		if parent_id then
			obj = sim:create(spawn_section,pos,lv,gv,parent_id)
		else
			obj = sim:create(spawn_section,pos,lv,gv)
		end
		if obj then
			-- если это нпс или монстр
			if not self.item_spawn then
				if self.binder_logic then
					self:binded_logic(obj)
				else
					obj:brain():update()
				end
				prop = self.sectSpawnProps[spawn_section]
				smart_id = obj:smart_terrain_id()
				-- если респавнер под собственную логику, или логику через нетпакет,
				-- либо обычный респавнер и объект затянуло в гулаг
				if prop.check or self.binder_logic or smart_id ~= 65535 then
					-- запишем объект в таблицу
					table_insert(self.spawned_obj,obj.id)
					return true
				end
				-- если обычный респавнер и объект остался без работы
				sim:release(obj,true)
				return false
			end
			-- запись объекта в таблицу
			table_insert(self.spawned_obj,obj.id)
			return true
		end
	return false
end

--' Генерируем позицию для рандомного респавнера
function se_respawn:generate_pos(gv)
	local actor = db.actor
	local gg = game_graph()
	local gdist = 100000000
	local apos,agv,gpos,gvn,gvx,lid,lpos,lv,lvx,ngv,nlv,npos
	-- запуск цикла выбора позиции по левел_вертексу
	repeat
		-- переменная остановки цикла
		local stop = 0
		-- определим локацию
		agv = actor:game_vertex_id()
		lid = gg:vertex(agv):level_id()
		lvx = ex_level.vertex_setting[lid][3]
		-- выбор левел вертекса
		lv = math_random(1,lvx)
		lpos = level.vertex_position(lv)
		apos = actor:position()
		-- ограничим спавн дистанцией до ГГ и запретными зонами
		if lpos:distance_to_sqr(apos) < 400 or not amk_anoms.check_coordinates(lpos) then
			stop = 0
		else
		nlv = lv
		npos = level.vertex_position(nlv)
		stop = 1
	end
	until stop == 1
	-- находим гейм вертекс
	gvn = ex_level.vertex_setting[lid][1]
	gvx = ex_level.vertex_setting[lid][2]
	for gv = gvn, gvx do
		gpos = gg:vertex(gv):level_point()
		if gpos:distance_to_sqr(npos) < gdist then
			gdist = gpos:distance_to_sqr(npos)
			ngv = gv
		end
	end
	return npos,nlv,ngv
end

--' Попытка записать логику через нетпакет(работает некорректно!!! как и вся логика через нетпакет)
function se_respawn:binded_logic(sobj)
	local cfg_name = self.binder_logic
	if not cfg_name then
		return
	end
	if IAmAMonster[sobj:clsid()] or IAmAStalker[sobj:clsid()] then
		local pk = get_netpk( sobj, 1 )
		ASSERT( ( pk and pk:isOk() ), "can't read netpacket of %s", sobj:name() )
		local data = pk:get()
		data.custom_data:set( "[logic]\ncfg = scripts\\amk\\"..cfg_name..".ltx" )
		pk:set( data )
	end
end

--' Разрегистпрация объекта
function se_respawn:on_unregister()
	cse_alife_smart_zone.on_unregister(self)
end

--' Чтение параметров респавнера:
-- запускается из se_respawn - STATE_Read,on_register; amk_mod.spawn_unspawned_respawners_2
function respawn_params(sobj)
	if sobj.init_params then
		return
	end
	local ini = sobj:spawn_ini()
	if not ini:section_exist(section_name) then
		return
	end
	-- секции спавна - единственный обязательный параметр
	sobj.respawn_section = r_spawns(ini,section_name,"respawn_section",sobj.sectSpawnProps)
	if not sobj.respawn_section then
		return
	end
	-- спавн объектов не принадлежащих к классу нпс и монстров\true\
	sobj.item_spawn = r_bool(ini,section_name,"item_spawn",nil)
	-- максимальное количество обьектов, поддерживаемое респавнером
	sobj.max_spawn = r_num(ini,section_name,"max_spawn",1)
	-- стори_ид парента(может быть несколько)
	sobj.parent = r_tab(ini,section_name,"parent",nil)
	-- выбор рандомной позиции\true\
	sobj.rand_position = r_bool(ini,section_name,"rand_position",nil)
	-- дистанция до ГГ, меньше которой в онлайне респавнер несработает
	sobj.respawn_radius = r_num(ini,section_name,"respawn_radius",-1)
	-- шанс заспавнить объект
	sobj.str_cond = r_str(ini,section_name,"conditions",def_cond)
	sobj.tab_cond = xr_logic.parse_condlist(sobj.str_cond,sobj,section_name,"conditions")
	-- авто удаление респавнера
	sobj.str_auto_dell = r_str(ini,section_name,"auto_dell")
	if sobj.str_auto_dell then
		sobj.tab_auto_dell = xr_logic.parse_condlist(sobj.str_auto_dell,nil,section_name,"auto_dell")
	end
	-- временной интервал между спавном
	sobj.idle_spawn = r_str(ini,section_name,"idle_spawn",time_spawn)
	if idle_spawn_preset[sobj.idle_spawn] then
		sobj.idle_spawn = idle_spawn_preset[sobj.idle_spawn]
	else
		sobj.idle_spawn = tonumber(sobj.idle_spawn)
	end
	-- амковские респавнеры
	sobj.amk_name = r_str(ini,section_name,"amk_name",nil)
	-- запись логики через нетпакет
	sobj.binder_logic = r_str(ini,section_name,"creature_binded_logic",nil)
	-- инициализация таймера
	if sobj.rt_read == false then
		if not sobj.rand_position and not sobj.tab_auto_dell and sobj.idle_spawn ~= -1 then
			sobj.respawn_time = game.CTime()
		end
		sobj.rt_read = true
	end
	-- запись в таблицу
	respawners[sobj:name()] = sobj
	sobj.init_params = true
end

function npc_clsid(cls)
	return (cls and (IAmAStalker[cls] or IAmAMonster[cls])) or false
end

--' Вызов респавнера по имени:
-- запускается из se_smart_terrain:call_respawn(),xr_effects.respawner_spawn()
function spawn(name)
	local spawner = respawners[name]
	if spawner then
		-- если это обычный респавнер - подсчитаем возможное количество объектов для спавна:
		local count = spawner.max_spawn - #spawner.spawned_obj
		-- если это заполнение ящика при гулаге
		if spawner.item_spawn and spawner.idle_spawn == -1 then
			-- если есть место - ограничим одним предметом, с шансом 50:
			if count > 0 then
				count = math_random(0,1)
			-- иначе очистим таблицу
			else
				spawner.spawned_obj = {}
			end
		end
		-- проверим сондлист
		local prob = xr_logic.pick_section_from_condlist(db.actor_proxy,spawner,spawner.tab_cond)
		local num = tonumber(prob)
		if num ~= 0 and count > 0 then
			for i = 1, count do
				-- не прерываем цикл, если не выпадет шанс
				if math_random(100) <= num then
					if spawner:create() == false then
						return
					end
				end
			end
		end
	end
end

--' Функция спавна патронов:
function create_ammo(sect,pos,lv,gv,pid,num)
	local sim = alife()
	local box_size = getIniValueU32Simple(sect,"box_size")
	while num > box_size do
		sim:create_ammo(sect,pos,lv,gv,pid,box_size)
		num = num - box_size
	end
	if num > 0 then
		sim:create_ammo(sect,pos,lv,gv,pid,num)
	end
end